#!/bin/bash -eux

k8s__main(){
  #k8s_kube_dir
  #k8s_disable_swap
  # install the kubernetes source list separately to check what version of Docker is supported
  #k8s_install_kubernetes_source_list
  #k8s_install_docker '18.04'
  #k8s_install_kubeadm '1.10.2-00'
  #k8s_update_cmdline
  #k8s_locate_master
  #k8s_set_hostname
  #reboot now
  k8s_join_cluster
}

# user home
k8s_user=pi
k8s_home=$(sudo -u $k8s_user sh -c 'echo $HOME')
k8s_kube_dir=$k8s_home/.kube
k8s_kubeconfig="--kubeconfig /etc/kubernetes/admin.conf"

k8s_kube_dir(){
  mkdir -p $k8s_kube_dir
  chown -R $(stat -c '%u' $k8s_home):$(stat -c '%g' $k8s_home) $k8s_kube_dir
}

k8s_disable_swap(){
  dphys-swapfile swapoff && \
    dphys-swapfile uninstall && \
    update-rc.d dphys-swapfile remove
}

k8s__get_kubeadm_version(){
  apt policy kubeadm | awk '/Candidate:/{gsub("-.*","");print $NF}'
}

k8s__get_latest_valid_docker_version(){
  # git_tag should [closely] match the version apt reports as the install candidate
  # The k8s__get_kubeadm_version function tries to retrieve that version, but is not guaranteed to exactly match a valid tag
  git_tag=$1
  # git tag examples: master, v1.12.2, release-1.12
  # to find tags:
  #   https://github.com/kubernetes/kubernetes/releases
  #   https://github.com/kubernetes/kubernetes/tags
  #   https://github.com/kubernetes/kubernetes/branches
  src_url="https://raw.githubusercontent.com/kubernetes/kubernetes/$git_tag/cmd/kubeadm/app/util/system/docker_validator.go"
  src_var='latestValidatedDockerVersion'
  curl -s $src_url | awk '/'$src_var'.*=/{gsub("\"","");print $NF}'
}

k8s_install_docker(){
  # compare the values of these 2 and decide if you need to specify a version:
  #   \_ https://github.com/kubernetes/kubernetes/search?q=latestValidatedDockerVersion&unscoped_q=latestValidatedDockerVersion
  #   \_ sudo apt policy docker-ce
  # The safe way is like this...
  #   export VERSION=18.06
  # This way is trying pretty hard to be clever and it may have problems...
  docker_version=${1:-}
  (
    if [[ -n $docker_version ]]; then
      export VERSION=$docker_version
    else
      export VERSION=$(k8s__get_latest_valid_docker_version v$(k8s__get_kubeadm_version))
    fi
    curl -sSL get.docker.com | sh && \
      usermod pi -aG docker
    unset VERSION
  )
  # This small container is used to advertise the master. It must be pulled early to speed the election later.
  docker pull hypriot/rpi-busybox-httpd &
}

k8s_install_kubernetes_source_list(){
  curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | \
    apt-key add - && \
  echo "deb http://apt.kubernetes.io/ kubernetes-xenial main" | \
    tee /etc/apt/sources.list.d/kubernetes.list && \
  apt update -q
}

k8s_install_kubeadm(){
  kube_version=${1:-}
  [[ -n $kube_version ]] && kube_version="=$kube_version kubectl=$kube_version kubelet=$kube_version"
  apt install -qy kubeadm$kube_version
}

k8s_update_cmdline(){
  sudo cp /boot/cmdline.txt /boot/cmdline_backup.txt
  for val in "cgroup_enable=memory" "cgroup_memory=1" "cgroup_enable=cpuset"; do
    grep -q "$val" /boot/cmdline.txt || sed -i "s/rootwait/rootwait $val/" /boot/cmdline.txt
  done
}

k8s_locate_master(){
  # NOTE: nmap is used to detect existing master nodes
  apt install -qy nmap
  k8s_master="$(nmap -v -sT -p 6444 $(ip address show wlan0 | awk '$1=="inet"{print $2}') | awk '/Discovered open port/{print $6}')"
}

k8s__wait_msg="kubeadm initializing"
k8s__advertise_master(){
    echo $k8s__wait_msg> $k8s_kube_dir/join.sh
    k8s_kube_dir
    docker run --rm --name web -v $k8s_kube_dir/join.sh:/www/index.html -d -p 6444:80 hypriot/rpi-busybox-httpd
}

k8s__choose_hostname(){
  if [[ -z $k8s_master ]]; then
    k8s__advertise_master
    hostname=k8s-master-1
  else
    hostname=k8s-node
  fi
}

k8s_set_hostname(){
  k8s__choose_hostname
  hostnamectl --transient set-hostname $hostname
  hostnamectl --static    set-hostname $hostname
  hostnamectl --pretty    set-hostname $hostname
  sed -i s/raspberrypi/$hostname/g /etc/hosts
}

k8s__kubeadm_init(){
  kubeadm init --token-ttl=0 | tee $k8s_kube_dir/init.out
  echo $(grep -- '--discovery-token-ca-cert-hash' $k8s_kube_dir/init.out) > $k8s_kube_dir/join.sh
  cp -i /etc/kubernetes/admin.conf $k8s_kube_dir/config
  k8s_kube_dir
  k8s__taint_master
}

k8s__kubeadm_join(){
  echo $k8s__wait_msg> $k8s_kube_dir/join.sh
  while [[ $(cat $k8s_kube_dir/join.sh) == $k8s__wait_msg ]]; do
    curl -slo $k8s_kube_dir/join.sh $k8s_master:6444
    sleep 5
  done
  source $k8s_kube_dir/join.sh
}

k8s__taint_master(){
  msg="Waiting for master node to show up..."
  while ! (kubectl $k8s_kubeconfig get nodes | grep -q master); do
    echo -n $msg
    msg=' .'
    sleep 2
  done
  [[ $msg = ' .' ]] && echo
  # schedule pods on the master (taint it with the node role)
  kubectl $k8s_kubeconfig taint nodes --all node-role.kubernetes.io/master-
}

k8s_join_cluster(){
  if [[ $(hostname) =~ 'master' ]]; then
    k8s__kubeadm_init
    k8s_add_weave_net
  else
    k8s__kubeadm_join
    k8s_add_weave_net
  fi
}

k8s_add_weave_net(){
  k8s_version="$(kubectl $k8s_kubeconfig version | base64 | tr -d '\n')"
  kubectl $k8s_kubeconfig apply -f "https://cloud.weave.works/k8s/net?k8s-version=$k8s_version"
}

[ "$0" = "$BASH_SOURCE" ] && k8s__main 
